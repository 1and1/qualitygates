package de.binarytree.plugins.qualitygates.steps.dependencycheck;

import hudson.Launcher;
import hudson.model.BuildListener;
import hudson.model.Result;
import hudson.model.AbstractBuild;

import java.io.File;
import java.io.IOException;

import de.binarytree.plugins.qualitygates.GateStep;
import de.binarytree.plugins.qualitygates.result.GateStepReport;
import de.binarytree.plugins.qualitygates.steps.dependencycheck.parser.BuildLogFileParser;

/**
 * This check evaluates the log generated by mvn dependency:analyze.
 * 
 * @author Marcel von Maltitz
 * 
 */
public abstract class DependencyCheck extends GateStep {

    public DependencyCheck() {
        super();
    }

    /**
     * Analyzes the build log and reports the result using the given
     * {@link GateStepReport}.
     * 
     * @param build
     *            the build of which the log shall be analyzed
     * @param checkReport
     *            the report which gathers the result
     * @throws IOException
     *             when the log could not be accessed or read
     */
    protected abstract void processBuildLog(AbstractBuild<?, ?> build,
            GateStepReport checkReport) throws IOException;

    @Override
    public void doStep(AbstractBuild<?, ?> build, Launcher launcher,
            BuildListener listener, GateStepReport checkReport) {
        if (!buildExists(build)) {
            failCheckDueToInexistententBuild(checkReport);
        } else {
            try {
                processBuildLog(build, checkReport);
            } catch (IOException e) {
                failStepWithExceptionAsReason(checkReport, e);
            }
        }

    }

    private boolean buildExists(AbstractBuild<?, ?> build) {
        Result result = build.getResult();
        return Result.SUCCESS.equals(result) || Result.UNSTABLE.equals(result);
    }

    private void failCheckDueToInexistententBuild(GateStepReport checkReport) {
        checkReport.setResult(Result.FAILURE,
                "Cannot proceed, build has not been successful");
    }

    /**
     * Reads the log file and returns a corresponding log file parser. 
     * @param build the build of which the log shall be analyzed
     * @return a {@link BuildLogFileParser} for the read log file 
     * @throws IOException when the log file could not be accessed or read
     */
    protected BuildLogFileParser parseBuildLogFile(AbstractBuild<?, ?> build)
            throws IOException {
        File logFile = build.getLogFile();
        BuildLogFileParser logFileParser = createLogFileParser();
        logFileParser.parseLogFile(logFile);
        return logFileParser;
    }

    /**
     * Returns a new log file parser. 
     * @return a new log file parser
     */
    protected BuildLogFileParser createLogFileParser() {
        return new BuildLogFileParser();
    }

}